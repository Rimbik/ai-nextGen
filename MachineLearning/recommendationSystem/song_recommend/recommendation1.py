# -*- coding: utf-8 -*-
"""recommendation1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14AmYJgfsEaumZ2UEvQnsdVI-9l2TY5Db
"""

import pandas as pd
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

# Sample dataset with metadata
data = {
    "song":   ["Blinding Lights", "Shape of You", "Bohemian Rhapsody", "Someone Like You", "Uptown Funk"],
    "artist": ["The Weeknd",      "Ed Sheeran",   "Queen", "Adele", "Bruno Mars"],
    "genre":  ["Pop",             "Pop",          "Rock", "Ballad", "Funk"],
    "mood":   ["Energetic",       "Romantic",     "Dramatic", "Sad", "Happy"],
    "energy": ["High",            "Medium",       "Medium",   "Low", "High"]
}

df = pd.DataFrame(data)

df

# Combine text features into a single string
df["features"] = df["genre"] + " " + df["mood"] + " " + df["energy"]

# TF-IDF Vectorization
tfidf = TfidfVectorizer(stop_words="english")
tfidf_matrix = tfidf.fit_transform(df["features"])

# Compute Cosine Similarity
cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)

# Function to recommend similar songs
def recommend_song(song_name, df, cosine_sim, top_n=2):
    if song_name not in df["song"].values:
        return "Song not found in the database."

    idx = df[df["song"] == song_name].index[0]  # Get song index
    sim_scores = list(enumerate(cosine_sim[idx]))  # Similarity scores
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)  # Sort
    sim_scores = sim_scores[1:top_n+1]  # Get top matches excluding itself

    song_indices = [i[0] for i in sim_scores]

    return df["song"].iloc[song_indices].tolist()

# Example Usage
print(recommend_song("Uptown Funk", df, cosine_sim, 1))